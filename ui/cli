#!/usr/bin/env node
const doc = (`
Start a visualization server or build a static site.

Usage:
  artisan-ui [<extPath>] [--port=<port>]
  artisan-ui serve [<extPath>] [--port=<port>]
  artisan-ui build [<extPath>] [--dst=<dst>]
  artisan-ui -h | --help

Options:
  --port=<port>  The port on which to serve [default: 1234]
  --dst=<dst>    The path to which the site should be written

"artisan-ui ..." is shorthand for "artisan-ui serve ...".
`)

const fs = require('fs-extra')
const path = require('path')

const { docopt } = require('docopt')
const express = require('express')
const handlebars = require('handlebars')
const isUrl = require('is-url')
const yaml = require('js-yaml')
const rollup = require('rollup')
const commonjsPlugin = require('rollup-plugin-commonjs')
const resolvePlugin = require('rollup-plugin-node-resolve')
const sucrasePlugin = require('rollup-plugin-sucrase')

//- Parse command-line arguments. ---------------------------------------------

const args = docopt(doc)
args.extPath = args['<extPath>'] ? path.resolve(args['<extPath>']) : null
args.port = parseInt(args['--port'])

if (args.build) {
  console.error('Static site generation insn\'t yet implemented :/')
  process.exit(1)
}

//- Start a development server, and a watcher, if necessary. ------------------

if (args.extPath !== null) {
  const state = {
    prelude: { scripts: [], styles: [], bindings: {} },
    timestamps: { prelude: 0, extension: 0 }
  }
  let serving = false
  watch(args, state).on('event', e => {
    if (e.code === 'END' && !serving) {
      serving = true
      serve(args, state)
    }
    else if (e.code === 'FATAL') {
      console.error(
        'Rollup (ArtisanUI\'s module bundler) encountered a fatal error.\n' +
        'This can happen during the initial build when there are\n' +
        'syntax errors in your extension. (See Rollup issue #1773.)'
      )
    }
  })
}
else {
  serve(args)
}

//- Define the Rollup watcher. ------------------------------------------------

function watch(args, state) {
  const coreBindings = {
    'react': 'React',
    'react-dom': 'ReactDOM',
    'numjs': 'nj'
  }
  return rollup.watch({
    input: args.extPath,
    external: id => (
      state.prelude.bindings.hasOwnProperty(id) ||
      coreBindings.hasOwnProperty(id)
    ),
    output: {
      file: '.artisan-ui/index.js',
      format: 'iife',
      name: 'Extension',
      globals: id => (
        state.prelude.bindings[id] || coreBindings[id]
      ),
      exports: 'named'
    },
    plugins: [
      sucrasePlugin({
        transforms: ['jsx', 'typescript'],
        exclude: ['node_modules/**']
      }),
      commonjsPlugin(),
      resolvePlugin(),
      stateUpdaterPlugin(state),
      errorConverterPlugin()
    ],
    onwarn: (warning, propagate) => {
      if (warning.code !== 'THIS_IS_UNDEFINED')
        propagate(warning)
    },
    treeshake: false
  })
}

//- Define a plugin that updates the watcher state. ---------------------------

function stateUpdaterPlugin(state) {
  return {
    buildStart() {
      const prelude = readPrelude(args.extPath)
      const now = Date.now()
      if (JSON.stringify(prelude) !== JSON.stringify(state.prelude)) {
        state.prelude = prelude
        state.timestamps.prelude = now
      }
      state.timestamps.extension = now
    }
  }
}


function readPrelude(extPath) {
  const prelude = { scripts: [], styles: [], bindings: {} }

  if (extPath !== null) {
    const extSrc = fs.readFileSync(extPath, 'utf8')
    const firstTokenComment = extSrc.match(/^\s*\/\*((?:.|\n)*?)\*\//)

    if (firstTokenComment !== null) {
      try {
        const header = yaml.load(firstTokenComment[1])
        const resolve = x => isUrl(x) ? x : `/__extension/deps/${x}`
        prelude.scripts = (header.scripts || []).map(resolve)
        prelude.styles = (header.styles || []).map(resolve)
        prelude.bindings = header.bindings || {}
      }
      catch (_) {}
    }
  }

  return prelude
}

//- Define a plugin that converts build errors to valid extensions. -----------

function errorConverterPlugin() {
  return {
    buildEnd(error) {
      if (error) {
        const ext = extensionFromError(error.message)
        fs.outputFileSync('.artisan-ui/index.js', ext)
        fs.removeSync('.artisan-ui/index.js.map')
      }
    }
  }
}


function extensionFromError(msg) {
  return (`
    (() => {
      const $ = React.createElement
      const msg = ${JSON.stringify(msg)}
      window.Extension = {
        default: {
          views: [['**', () => (
            $('pre', {style: {color: "#800"}},
              $('code', {}, msg)
            )
          )]]
        }
      }
    })()
  `)
}

//- Define the server. --------------------------------------------------------

function serve(args, state) {
  const app = express()
  const indexHtml = handlebars.compile(
    fs.readFileSync(`${__dirname}/index.html`, 'utf8')
  )

  // Core bundle and its dependencies
  const depPath = path.resolve(require.resolve('react') + '/../..')
  app.use('/__artisan-ui', express.static(__dirname))
  app.use('/__artisan-ui/deps', express.static(depPath))

  // User-defined extension
  app.use('/__extension', express.static(path.resolve('.artisan-ui')))
  app.use('/__extension/deps', express.static(path.resolve('.')))
  app.get('/__extension/timestamps.json', (_, res) => (
    res.json(state.timestamps))
  )

  // `index.html`
  app.get('/*', (_, res) => {
    res.send(indexHtml({
      extension: args.extPath !== null,
      timestamps: state ? state.timestamps : null,
      scripts: state ? state.prelude.scripts : null,
      styles: state ? state.prelude.styles : null
    }))
  })

  app.listen(args.port)
}
